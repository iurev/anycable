# GRPC contains the General RPC module.
module GRPC
  # The ActiveCall class provides simple methods for sending marshallable
  # data to a call
  class ActiveCall
    include Core::TimeConsts

    attr_reader deadline: untyped

    attr_reader metadata_sent: untyped

    attr_reader metadata_to_send: untyped

    attr_reader peer: untyped

    attr_reader peer_cert: untyped

    # client_invoke begins a client invocation.
    #
    # Flow Control note: this blocks until flow control accepts that client
    # request can go ahead.
    #
    # deadline is the absolute deadline for the call.
    #
    # == Keyword Arguments ==
    # any keyword arguments are treated as metadata to be sent to the server
    # if a keyword value is a list, multiple metadata for it's key are sent
    #
    # @param call [Call] a call on which to start and invocation
    # @param metadata [Hash] the metadata
    def self.client_invoke: (untyped call, ?::Hash[untyped, untyped] metadata) -> untyped

    # Creates an ActiveCall.
    #
    # ActiveCall should only be created after a call is accepted.  That
    # means different things on a client and a server.  On the client, the
    # call is accepted after calling call.invoke.  On the server, this is
    # after call.accept.
    #
    # #initialize cannot determine if the call is accepted or not; so if a
    # call that's not accepted is used here, the error won't be visible until
    # the ActiveCall methods are called.
    #
    # deadline is the absolute deadline for the call.
    #
    # @param call [Call] the call used by the ActiveCall
    # @param marshal [Function] f(obj)->string that marshal requests
    # @param unmarshal [Function] f(string)->obj that unmarshals responses
    # @param deadline [Fixnum] the deadline for the call to complete
    # @param started [true|false] indicates that metadata was sent
    # @param metadata_received [true|false] indicates if metadata has already
    #     been received. Should always be true for server calls
    def initialize: (untyped call, untyped marshal, untyped unmarshal, untyped deadline, ?started: bool, ?metadata_received: bool, ?metadata_to_send: untyped?) -> void

    # Sends the initial metadata that has yet to be sent.
    # Does nothing if metadata has already been sent for this call.
    def send_initial_metadata: (?::Hash[untyped, untyped] new_metadata) -> untyped

    # output_metadata are provides access to hash that can be used to
    # save metadata to be sent as trailer
    def output_metadata: () -> untyped

    # cancelled indicates if the call was cancelled
    def cancelled?: () -> untyped

    # multi_req_view provides a restricted view of this ActiveCall for use
    # in a server client-streaming handler.
    def multi_req_view: () -> untyped

    # single_req_view provides a restricted view of this ActiveCall for use in
    # a server request-response handler.
    def single_req_view: () -> untyped

    # operation provides a restricted view of this ActiveCall for use as
    # a Operation.
    def operation: () -> untyped

    #
    # Returns a restricted view of this ActiveCall for use in interceptors
    #
    # @return [InterceptableView]
    #
    def interceptable: () -> untyped

    def receive_and_check_status: () -> untyped

    def attach_status_results_and_complete_call: (untyped recv_status_batch_result) -> untyped

    # remote_send sends a request to the remote endpoint.
    #
    # It blocks until the remote endpoint accepts the message.
    #
    # @param req [Object, String] the object to send or it's marshal form.
    # @param marshalled [false, true] indicates if the object is already
    # marshalled.
    def remote_send: (untyped req, ?bool marshalled) -> untyped

    # send_status sends a status to the remote endpoint.
    #
    # @param code [int] the status code to send
    # @param details [String] details
    # @param assert_finished [true, false] when true(default), waits for
    # FINISHED.
    # @param metadata [Hash] metadata to send to the server. If a value is a
    # list, mulitple metadata for its key are sent
    def send_status: (?untyped code, ?::String details, ?bool assert_finished, ?metadata: ::Hash[untyped, untyped]) -> nil

    # Intended for use on server-side calls when a single request from
    # the client is expected (i.e., unary and server-streaming RPC types).
    def read_unary_request: () -> untyped

    def server_unary_response: (untyped req, ?trailing_metadata: ::Hash[untyped, untyped], ?code: untyped, ?details: ::String) -> untyped

    # remote_read reads a response from the remote endpoint.
    #
    # It blocks until the remote endpoint replies with a message or status.
    # On receiving a message, it returns the response after unmarshalling it.
    # On receiving a status, it returns nil if the status is OK, otherwise
    # raising BadStatus
    def remote_read: () -> untyped

    def get_message_from_batch_result: (untyped recv_message_batch_result) -> (untyped | nil)

    # each_remote_read passes each response to the given block or returns an
    # enumerator the responses if no block is given.
    # Used to generate the request enumerable for
    # server-side client-streaming RPC's.
    #
    # == Enumerator ==
    #
    # * #next blocks until the remote endpoint sends a READ or FINISHED
    # * for each read, enumerator#next yields the response
    # * on status
    #    * if it's is OK, enumerator#next raises StopException
    #    * if is not OK, enumerator#next raises RuntimeException
    #
    # == Block ==
    #
    # * if provided it is executed for each response
    # * the call blocks until no more responses are provided
    #
    # @return [Enumerator] if no block was given
    def each_remote_read: () ?{ (untyped) -> untyped } -> untyped

    # each_remote_read_then_finish passes each response to the given block or
    # returns an enumerator of the responses if no block is given.
    #
    # It is like each_remote_read, but it blocks on finishing on detecting
    # the final message.
    #
    # == Enumerator ==
    #
    # * #next blocks until the remote endpoint sends a READ or FINISHED
    # * for each read, enumerator#next yields the response
    # * on status
    #    * if it's is OK, enumerator#next raises StopException
    #    * if is not OK, enumerator#next raises RuntimeException
    #
    # == Block ==
    #
    # * if provided it is executed for each response
    # * the call blocks until no more responses are provided
    #
    # @return [Enumerator] if no block was given
    def each_remote_read_then_finish: () ?{ (untyped) -> untyped } -> untyped

    # request_response sends a request to a GRPC server, and returns the
    # response.
    #
    # @param req [Object] the request sent to the server
    # @param metadata [Hash] metadata to be sent to the server. If a value is
    # a list, multiple metadata for its key are sent
    # @return [Object] the response received from the server
    def request_response: (untyped req, ?metadata: ::Hash[untyped, untyped]) -> untyped

    # client_streamer sends a stream of requests to a GRPC server, and
    # returns a single response.
    #
    # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
    # #each enumeration protocol. In the simplest case, requests will be an
    # array of marshallable objects; in typical case it will be an Enumerable
    # that allows dynamic construction of the marshallable objects.
    #
    # @param requests [Object] an Enumerable of requests to send
    # @param metadata [Hash] metadata to be sent to the server. If a value is
    # a list, multiple metadata for its key are sent
    # @return [Object] the response received from the server
    def client_streamer: (untyped requests, ?metadata: ::Hash[untyped, untyped]) -> untyped

    # server_streamer sends one request to the GRPC server, which yields a
    # stream of responses.
    #
    # responses provides an enumerator over the streamed responses, i.e. it
    # follows Ruby's #each iteration protocol.  The enumerator blocks while
    # waiting for each response, stops when the server signals that no
    # further responses will be supplied.  If the implicit block is provided,
    # it is executed with each response as the argument and no result is
    # returned.
    #
    # @param req [Object] the request sent to the server
    # @param metadata [Hash] metadata to be sent to the server. If a value is
    # a list, multiple metadata for its key are sent
    # @return [Enumerator|nil] a response Enumerator
    def server_streamer: (untyped req, ?metadata: ::Hash[untyped, untyped]) ?{ (untyped) -> untyped } -> untyped

    # bidi_streamer sends a stream of requests to the GRPC server, and yields
    # a stream of responses.
    #
    # This method takes an Enumerable of requests, and returns and enumerable
    # of responses.
    #
    # == requests ==
    #
    # requests provides an 'iterable' of Requests. I.e. it follows Ruby's
    # #each enumeration protocol. In the simplest case, requests will be an
    # array of marshallable objects; in typical case it will be an
    # Enumerable that allows dynamic construction of the marshallable
    # objects.
    #
    # == responses ==
    #
    # This is an enumerator of responses.  I.e, its #next method blocks
    # waiting for the next response.  Also, if at any point the block needs
    # to consume all the remaining responses, this can be done using #each or
    # #collect.  Calling #each or #collect should only be done if
    # the_call#writes_done has been called, otherwise the block will loop
    # forever.
    #
    # @param requests [Object] an Enumerable of requests to send
    # @param metadata [Hash] metadata to be sent to the server. If a value is
    # a list, multiple metadata for its key are sent
    # @return [Enumerator, nil] a response Enumerator
    def bidi_streamer: (untyped requests, ?metadata: ::Hash[untyped, untyped]) { () -> untyped } -> untyped

    # run_server_bidi orchestrates a BiDi stream processing on a server.
    #
    # N.B. gen_each_reply is a func(Enumerable<Requests>)
    #
    # It takes an enumerable of requests as an arg, in case there is a
    # relationship between the stream of requests and the stream of replies.
    #
    # This does not mean that must necessarily be one.  E.g, the replies
    # produced by gen_each_reply could ignore the received_msgs
    #
    # @param mth [Proc] generates the BiDi stream replies
    # @param interception_ctx [InterceptionContext]
    #
    def run_server_bidi: (untyped mth, untyped interception_ctx) -> untyped

    # Waits till an operation completes
    def wait: () -> (nil | untyped)

    # Signals that an operation is done.
    # Only relevant on the client-side (this is a no-op on the server-side)
    def op_is_done: () -> (nil | untyped)

    # Add to the metadata that will be sent from the server.
    # Fails if metadata has already been sent.
    # Unused by client calls.
    def merge_metadata_to_send: (?::Hash[untyped, untyped] new_metadata) -> untyped

    def attach_peer_cert: (untyped peer_cert) -> untyped

    private

    # To be called once the "input stream" has been completelly
    # read through (i.e, done reading from client or received status)
    # note this is idempotent
    def set_input_stream_done: () -> untyped

    # To be called once the "output stream" has been completelly
    # sent through (i.e, done sending from client or sent status)
    # note this is idempotent
    def set_output_stream_done: () -> untyped

    def maybe_finish_and_close_call_locked: () -> (nil | untyped)

    # Starts the call if not already started
    # @param metadata [Hash] metadata to be sent to the server. If a value is
    # a list, multiple metadata for its key are sent
    def start_call: (?::Hash[untyped, untyped] metadata) -> untyped

    def raise_error_if_already_executed: () -> untyped

    def self.view_class: (*untyped visible_methods) -> untyped

    # SingleReqView limits access to an ActiveCall's methods for use in server
    # handlers that receive just one request.
    SingleReqView: untyped

    # MultiReqView limits access to an ActiveCall's methods for use in
    # server client_streamer handlers.
    MultiReqView: untyped

    # Operation limits access to an ActiveCall's methods for use as
    # a Operation on the client.
    Operation: untyped

    # InterceptableView further limits access to an ActiveCall's methods
    # for use in interceptors on the client, exposing only the deadline
    InterceptableView: untyped
  end
end
