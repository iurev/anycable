# GRPC contains the General RPC module.
module GRPC
  # Pool is a simple thread pool.
  class Pool
    # Default keep alive period is 1s
    DEFAULT_KEEP_ALIVE: 1

    def initialize: (untyped size, ?keep_alive: untyped) -> void

    # Returns the number of jobs waiting
    def jobs_waiting: () -> untyped

    def ready_for_work?: () -> untyped

    # Runs the given block on the queue with the provided args.
    #
    # @param args the args passed blk when it is called
    # @param blk the block to call
    def schedule: (*untyped args) { () -> untyped } -> (nil | untyped)

    # Starts running the jobs in the thread pool.
    def start: () -> untyped

    # Stops the jobs in the pool
    def stop: () -> untyped

    # Forcibly shutdown any threads that are still alive.
    def forcibly_stop_workers: () -> (nil | untyped)

    # removes the threads from workers, and signal when all the
    # threads are complete.
    def remove_current_thread: () -> untyped

    def loop_execute_jobs: (untyped worker_queue) -> untyped
  end

  # RpcServer hosts a number of services and makes them available on the
  # network.
  class RpcServer
    include Core::TimeConsts

    # Default thread pool size is 30
    DEFAULT_POOL_SIZE: 30

    # Deprecated due to internal changes to the thread pool
    DEFAULT_MAX_WAITING_REQUESTS: 20

    # Default poll period is 1s
    DEFAULT_POLL_PERIOD: 1

    # Signal check period is 0.25s
    SIGNAL_CHECK_PERIOD: ::Float

    # setup_connect_md_proc is used by #initialize to validate the
    # connect_md_proc.
    def self.setup_connect_md_proc: (untyped a_proc) -> (nil | untyped)

    # Creates a new RpcServer.
    #
    # The RPC server is configured using keyword arguments.
    #
    # There are some specific keyword args used to configure the RpcServer
    # instance.
    #
    # * pool_size: the size of the thread pool the server uses to run its
    # threads. No more concurrent requests can be made than the size
    # of the thread pool
    #
    # * max_waiting_requests: Deprecated due to internal changes to the thread
    # pool. This is still an argument for compatibility but is ignored.
    #
    # * poll_period: The amount of time in seconds to wait for
    # currently-serviced RPC's to finish before cancelling them when shutting
    # down the server.
    #
    # * pool_keep_alive: The amount of time in seconds to wait
    # for currently busy thread-pool threads to finish before
    # forcing an abrupt exit to each thread.
    #
    # * connect_md_proc:
    # when non-nil is a proc for determining metadata to send back the client
    # on receiving an invocation req.  The proc signature is:
    #   {key: val, ..} func(method_name, {key: val, ...})
    #
    # * server_args:
    # A server arguments hash to be passed down to the underlying core server
    #
    # * interceptors:
    # An array of GRPC::ServerInterceptor objects that will be used for
    # intercepting server handlers to provide extra functionality.
    # Interceptors are an EXPERIMENTAL API.
    #
    def initialize: (?pool_size: untyped, ?max_waiting_requests: untyped, ?poll_period: untyped, ?pool_keep_alive: untyped, ?connect_md_proc: untyped?, ?server_args: ::Hash[untyped, untyped], ?interceptors: untyped) -> void

    # stops a running server
    #
    # the call has no impact if the server is already stopped, otherwise
    # server's current call loop is it's last.
    def stop: () -> (nil | untyped)

    def running_state: () -> untyped

    # Can only be called while holding @run_mutex
    def transition_running_state: (untyped target_state) -> untyped

    def running?: () -> untyped

    def stopped?: () -> untyped

    # Is called from other threads to wait for #run to start up the server.
    #
    # If run has not been called, this returns immediately.
    #
    # @param timeout [Numeric] number of seconds to wait
    # @return [true, false] true if the server is running, false otherwise
    def wait_till_running: (?untyped? timeout) -> untyped

    # handle registration of classes
    #
    # service is either a class that includes GRPC::GenericService and whose
    # #new function can be called without argument or any instance of such a
    # class.
    #
    # E.g, after
    #
    # class Divider
    #   include GRPC::GenericService
    #   rpc :div DivArgs, DivReply    # single request, single response
    #   def initialize(optional_arg='default option') # no args
    #     ...
    #   end
    #
    # srv = GRPC::RpcServer.new(...)
    #
    # # Either of these works
    #
    # srv.handle(Divider)
    #
    # # or
    #
    # srv.handle(Divider.new('replace optional arg'))
    #
    # It raises RuntimeError:
    # - if service is not valid service class or object
    # - its handler methods are already registered
    # - if the server is already running
    #
    # @param service [Object|Class] a service class or object as described
    #        above
    def handle: (untyped service) -> untyped

    # runs the server
    #
    # - if no rpc_descs are registered, this exits immediately, otherwise it
    #   continues running permanently and does not return until program exit.
    #
    # - #running? returns true after this is called, until #stop cause the
    #   the server to stop.
    def run: () -> untyped

    alias run_till_terminated run

    # runs the server with signal handlers
    # @param signals
    #     List of String, Integer or both representing signals that the user
    #     would like to send to the server for graceful shutdown
    # @param wait_interval (optional)
    #     Integer seconds that user would like stop_server_thread to poll
    #     stop_server
    def run_till_terminated_or_interrupted: (untyped signals, ?::Integer wait_interval) -> untyped

    # Sends RESOURCE_EXHAUSTED if there are too many unprocessed jobs
    def available?: (untyped an_rpc) -> (untyped | nil)

    # Sends UNIMPLEMENTED if the method is not implemented by this server
    def implemented?: (untyped an_rpc) -> (untyped | nil)

    # handles calls to the server
    def loop_handle_server_calls: () -> untyped

    def new_active_server_call: (untyped an_rpc) -> (nil | ::Array[untyped])

    def rpc_descs: () -> untyped

    def rpc_handlers: () -> untyped

    def assert_valid_service_class: (untyped cls) -> untyped

    # This should be called while holding @run_mutex
    def add_rpc_descs_for: (untyped service) -> untyped
  end
end
