module WEBrick
  module Utils
    #
    # Sets IO operations on +io+ to be non-blocking
    def self?.set_non_blocking: (untyped io) -> (untyped | nil)

    #
    # Sets the close on exec flag for +io+
    def self?.set_close_on_exec: (untyped io) -> (untyped | nil)

    #
    # Changes the process's uid and gid to the ones of +user+
    def self?.su: (untyped user) -> untyped

    #
    # The server hostname
    def self?.getservername: () -> untyped

    #
    # Creates TCP server sockets bound to +address+:+port+ and returns them.
    #
    # It will create IPV4 and IPV6 sockets on all interfaces.
    def self?.create_listeners: (untyped address, untyped port) -> untyped

    #
    # Characters used to generate random strings
    RAND_CHARS: untyped

    #
    # Generates a random string of length +len+
    def self?.random_string: (untyped len) -> untyped

    #
    # Class used to manage timeout handlers across multiple threads.
    #
    # Timeout handlers should be managed by using the class methods which are
    # synchronized.
    #
    #   id = TimeoutHandler.register(10, Timeout::Error)
    #   begin
    #     sleep 20
    #     puts 'foo'
    #   ensure
    #     TimeoutHandler.cancel(id)
    #   end
    #
    # will raise Timeout::Error
    #
    #   id = TimeoutHandler.register(10, Timeout::Error)
    #   begin
    #     sleep 5
    #     puts 'foo'
    #   ensure
    #     TimeoutHandler.cancel(id)
    #   end
    #
    # will print 'foo'
    #
    class TimeoutHandler

      #
      # Mutex used to synchronize access across threads
      TimeoutMutex: untyped

      #
      # Registers a new timeout handler
      #
      # +time+:: Timeout in seconds
      # +exception+:: Exception to raise when timeout elapsed
      def self.register: (untyped seconds, untyped exception) -> untyped

      #
      # Cancels the timeout handler +id+
      def self.cancel: (untyped id) -> untyped

      def self.terminate: () -> untyped

      #
      # Creates a new TimeoutHandler.  You should use ::register and ::cancel
      # instead of creating the timeout handler directly.
      def initialize: () -> void

      private

      def watch: () -> untyped

      def watcher: () -> untyped

      public

      #
      # Interrupts the timeout handler +id+ and raises +exception+
      def interrupt: (untyped thread, untyped id, untyped exception) -> (untyped | nil)

      #
      # Registers a new timeout handler
      #
      # +time+:: Timeout in seconds
      # +exception+:: Exception to raise when timeout elapsed
      def register: (untyped thread, untyped time, untyped exception) -> untyped

      #
      # Cancels the timeout handler +id+
      def cancel: (untyped thread, untyped id) -> untyped

      #
      def terminate: () -> untyped
    end

    #
    # Executes the passed block and raises +exception+ if execution takes more
    # than +seconds+.
    #
    # If +seconds+ is zero or nil, simply executes the block
    def self?.timeout: (untyped seconds, ?untyped exception) { (untyped) -> untyped } -> untyped
  end
end
